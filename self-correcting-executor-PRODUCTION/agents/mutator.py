# ProtocolMutator: Reads outcomes, identifies failures, and rewrites
# protocol logic
import json
import os
from utils.logger import log


def mutate_protocol(protocol_name):
    """Analyze protocol outcomes and mutate if failure rate is high"""
    # Try database stats first, fall back to file stats
    try:
        from utils.db_tracker import get_protocol_stats, track_mutation

        stats = get_protocol_stats(protocol_name)
    except Exception:
        from utils.tracker import get_protocol_stats

        stats = get_protocol_stats(protocol_name)
        track_mutation = None  # No mutation tracking in file mode

    if not stats:
        log(f"No stats found for {protocol_name}. Nothing to mutate.")
        return False

    failure_rate = stats["failure_rate"]
    log(
        f"Protocol {protocol_name}: {
            stats['failures']}/{
            stats['total_executions']} failures (rate: {
                failure_rate:.2%})"
    )

    if failure_rate < 0.5:
        log(
            f"Mutation not needed. Failure rate acceptable: {
                failure_rate:.2%}"
        )
        return False

    # Rewrite protocol file with improved logic
    protocol_file = f"protocols/{protocol_name}.py"
    if not os.path.exists(protocol_file):
        log(f"No protocol source file found for {protocol_name}")
        return False

    log(
        f"ðŸ”„ Mutating protocol: {protocol_name} due to high failure rate ({
            failure_rate:.2%})"
    )

    # Read original code for backup
    with open(protocol_file, "r") as f:
        original_code = f.read()

    # Check if this is a simple random protocol or a complex one
    is_simple_protocol = any(
        keyword in original_code for keyword in ["randint", "random()", "bool(randint"]
    )

    if is_simple_protocol:
        # Generate improved random logic
        mutated_logic = f'''# Mutated protocol file - Auto-generated by ProtocolMutator
# Previous failure rate: {failure_rate:.2%}
# Mutation timestamp: {json.dumps({"timestamp": __import__("datetime").datetime.utcnow().isoformat()})}

def task():
    """Improved task implementation after mutation"""
    from random import choice, random

    # Enhanced logic with better success probability
    if random() < 0.8:  # 80% success rate instead of 50%
        result = {'success': True, 'action': 'optimized_execution', 'mutation_gen': 1}
    else:
        result = {'success': False, 'action': 'controlled_failure', 'mutation_gen': 1}

    return result
'''
    else:
        # Don't mutate complex protocols, just add a comment
        log(
            f"Protocol {protocol_name} appears to be a complex protocol, skipping automatic mutation"
        )
        return False

    try:
        # Backup original protocol
        backup_file = f"{protocol_file}.backup"
        with open(backup_file, "w") as backup:
            backup.write(original_code)

        # Write mutated protocol
        with open(protocol_file, "w") as f:
            f.write(mutated_logic)

        # Track mutation in database if available
        if track_mutation is not None:
            track_mutation(protocol_name, failure_rate, mutated_logic, original_code)

        log(
            f"âœ… Protocol {protocol_name} mutated successfully. Backup saved to {backup_file}"
        )
        return True

    except Exception as e:
        log(f"âŒ Failed to mutate protocol {protocol_name}: {e}")
        return False


def analyze_all_protocols():
    """Analyze and potentially mutate all protocols with recorded outcomes"""
    # Try database stats first, fall back to file stats
    try:
        from utils.db_tracker import get_all_stats

        all_stats = get_all_stats()
    except Exception:
        from utils.tracker import get_all_stats

        all_stats = get_all_stats()

    mutated_count = 0
    for stats in all_stats:
        protocol_name = stats["protocol"]
        if mutate_protocol(protocol_name):
            mutated_count += 1

    log(f"Analysis complete. {mutated_count} protocols were mutated.")
    return mutated_count
